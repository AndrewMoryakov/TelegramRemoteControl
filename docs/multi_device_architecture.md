# Архитектурный отчет: управление несколькими ПК через один Telegram‑бот

Дата: 2026-01-29

## 1) Контекст и цель
Нужно, чтобы **один Telegram‑бот** управлял **несколькими ПК** одного пользователя. Пользователь должен уметь переключать активное устройство и выполнять команды (скриншот, файловые операции, запуск команд и т.д.). На первом этапе Hub будет работать на домашнем сервере через Tailscale/Cloudflare Tunnel, затем перенос на VPS.

Ключевое ограничение: Telegram updates должны обрабатываться одним процессом. Поэтому несколько «ботов» на разных ПК с одним токеном невозможны — нужен **один Bot Service** и **отдельные агенты** на устройствах.

## 2) Рекомендуемая архитектура (целевой вариант)
### Компоненты
1) **Bot Service** (единственный экземпляр)
- Получает апдейты Telegram.
- Отображает UI в чате: список устройств, выбор активного, статус.
- Отправляет команды в Hub и пересылает ответы обратно в Telegram.
- Не зависит от конкретных устройств (stateless).

2) **Hub Service** (центральный шлюз)
- Хранит список устройств, их статус, ключи и “активное устройство” пользователя.
- Маршрутизирует команды между Bot Service и агентами.
- Держит постоянные подключения от агентов (SignalR/WebSocket/gRPC stream).
- Может хранить/проксировать файлы (например, скриншоты).

3) **Agent** (на каждом ПК)
- Подключается к Hub по исходящему соединению.
- Регистрируется и периодически шлёт heartbeat.
- Принимает команды от Hub, выполняет и отправляет результаты.

### Почему так
- Агенты за NAT и динамическими IP → только исходящее соединение.
- Один бот = одна точка входа, единое состояние “выбранного ПК”.
- Hub упрощает маршрутизацию, логирование, безопасность.

## 3) Сценарии и потоки
### 3.1 Регистрация устройства (pairing)
1) Агент запускается и получает `DeviceId`.
2) Агент отображает короткий код (например, `TRC-XXXX`).
3) Пользователь в Telegram вводит `/pair TRC-XXXX`.
4) Hub связывает `TelegramUserId` ↔ `DeviceId` и выдаёт агенту постоянный токен.

### 3.2 Выбор активного ПК
1) `/devices` → Bot Service → Hub → список устройств.
2) Пользователь выбирает устройство: `/use <device>`.
3) Hub сохраняет `ActiveDeviceId` для пользователя.

### 3.3 Выполнение команды
1) Пользователь вводит `/screenshot`.
2) Bot Service отправляет команду в Hub с `ActiveDeviceId`.
3) Hub пушит команду агенту.
4) Агент выполняет, отправляет результат в Hub.
5) Bot Service получает результат и отправляет в Telegram.

## 4) Связь и транспорт
### Вариант для домашнего сервера
- **Tailscale**: агенты и Hub в одной VPN, соединение стабильное.
- **Cloudflare Tunnel**: Hub доступен из интернета без открытых портов.

### Протокол
- Рекомендую **SignalR** (ASP.NET Core) для простоты и стабильности.
- Альтернатива: gRPC streaming или MQTT.

## 5) Хранение данных (минимум)
Даже при одном пользователе нужно хранить:
- `Devices`: DeviceId, Name, Os, LastSeen, Status, OwnerUserId
- `UserActiveDevice`: UserId → DeviceId
- `Commands`: CommandId, DeviceId, Payload, Status
- `CommandResults`: CommandId, Result, Files, Error

Для домашнего сервера достаточно **SQLite**. На VPS можно перейти на PostgreSQL.

## 6) Безопасность и контроль доступа
- Проверять `TelegramUserId` (один владелец).
- У каждого агента — **токен устройства**.
- Команды подписывать (HMAC) или использовать JWT.
- Ограничить права (в будущем), но сейчас “один пользователь” упрощает.

## 7) Работа с файлами (скриншоты и т.д.)
Варианты:
1) **Через Hub**: агент отправляет файл в Hub → Bot Service забирает и отправляет в Telegram.
2) **Через временный URL**: агент загружает файл на Hub, Hub отдаёт ссылку Bot Service.

На домашнем сервере проще вариант 1 (Hub хранит временно в `ProgramData`/`AppData` или в `storage/`).

## 8) Надёжность и офлайн
- Hub хранит очередь команд (с TTL).
- Агент шлёт heartbeats каждые 15–30 секунд.
- Bot показывает статус: online/offline, last seen.

## 9) Пошаговый план реализации
### Этап 1 (домашний сервер)
1) Вынести текущий Telegram‑бот в отдельный процесс (Bot Service).
2) Сделать Hub (ASP.NET Core + SignalR + SQLite).
3) Переделать текущий сервис в Agent:
   - подключение к Hub
   - регистрация и heartbeat
   - обработка команд
4) Добавить команды бота:
   - `/devices` — список
   - `/use <id>` — выбрать активное
   - `/pair <code>` — связать новое устройство

### Этап 2 (подготовка к VPS)
1) Поддержка переменных окружения (URL Hub, ключи).
2) Перевод хранения на PostgreSQL (миграции).
3) Опционально: хранение файлов в S3‑совместимом хранилище.

## 10) Минимальный API/события (предложение)
### Hub REST (упрощённо)
- `POST /pair` → связать устройство
- `GET /devices` → список устройств
- `POST /devices/{id}/select` → выбрать активное

### Hub SignalR
- `AgentConnected(DeviceInfo)`
- `Command(DeviceId, Payload)`
- `CommandResult(CommandId, ResultPayload)`
- `Heartbeat(DeviceId)`

## 11) Риски и узкие места
- Зависимость от стабильности домашнего интернета.
- Доставка файлов через Hub (если большие) — нужен лимит размера.
- Сессионные команды (например, скриншот) требуют корректного доступа к пользовательской сессии на ПК.

## 12) Итог
Рекомендуемая архитектура: **Bot Service + Hub + Agents**. Это решает многокомпьютерный контроль, устраняет конфликт Telegram‑бота, обеспечивает удобное переключение устройств и готово к миграции на VPS без серьёзной переработки.

---

Если нужно, могу:
- подготовить структуру проектов (Hub + Agent + Bot Service),
- наметить контракты сообщений и классы DTO,
- сделать минимальный прототип SignalR‑связки.
